import Smt
import Lean
import Veil.SMT.Main
import Veil.DSL.TacticUtil
import Veil.Tactic.Main
import Auto.Solver.SMT
import Auto

open Lean hiding Command Declaration

namespace Tactic
open Lean Elab Command Tactic

abbrev Context := Lean.Elab.Tactic.Context
abbrev State := Lean.Elab.Tactic.State

@[inline] private def _runCore (x : TacticM α) (ctx : Context) (s : State) : TermElabM (α × State) :=
  x ctx |>.run s

@[inline] private def _runCore' (x : TacticM α) (ctx : Context) (s : State) : TermElabM α :=
  Prod.fst <$> _runCore x ctx s

/-- This is a copy of `Tactic.run` that returns a value. -/
def run  (mvarId : MVarId) (x : TacticM α) : TermElabM (α × List MVarId) :=
  mvarId.withContext do
   let pendingMVarsSaved := (← get).pendingMVars
   modify fun s => { s with pendingMVars := [] }
   let aux : TacticM (α × List MVarId) :=
     try
       let ret ← x
       let unsolved ← getUnsolvedGoals
       return (ret, unsolved)
     catch ex =>
         throw ex
   try
     _runCore' aux { elaborator := .anonymous } { goals := [mvarId] }
   finally
     modify fun s => { s with pendingMVars := pendingMVarsSaved }
end Tactic

/-- A version of `Auto.IR.SMT.processSuggestedName` that assumes
`name` arguments are unique. We use this to "reverse-engineer" what
names our indicator variables will have in the SMT-LIB generated by Lean Auto,
under the assumption that they have unique names (which is very likely true). -/
def getLeanAutoNameFor (name : String) : CoreM String := do
    let mut preName := name.map (fun c => if allowed c then c else '_')
    if preName.all (fun c => c == '_') then
      preName := "pl_" ++ preName
    if preName.back.isDigit then
      preName := preName ++ "_"
    -- If the name has not actually been used before as an argument to
    -- `processSuggestedName`, this will in fact be its name in the SMT-LIB.
    return "_" ++ preName
  where
    allowed (c : Char) :=
      let allowedStr : String :=
        "~!@$%^&*_-+=<>.?/" ++
        "ΑαΒβΓγΔδΕεΖζΗηΘθΙιΚκΛλΜμΝνΞξΟοΠπΡρΣσςΤτΥυΦφΧχΨψΩω" ++
        "₀₁₂₃₄₅₆₇₈₉"
      let allowedSet : Std.HashSet UInt32 := Std.HashSet.insertMany Std.HashSet.empty (List.map Char.val allowedStr.toList)
      c.isAlphanum || allowedSet.contains c.val

def indicatorVariableName (name : Name) : CoreM String := do
  let smtName ← match sauto.smt.translator.get (← getOptions) with
  | Translator.leanAuto => getLeanAutoNameFor name.toString
  | Translator.leanSmt => pure name.toString
  return smtName

open Lean Elab Command Term Meta Tactic in
def getQueryForGoal : TacticM String := withMainContext do
  let idents ← getPropsInContext
  let stx := ( ← `(Smt.sauto| sauto [$[$idents:ident],*])).raw
  let mv ← Tactic.getMainGoal
  let translatorToUse := sauto.smt.translator.get (← getOptions)
  let cmdString ←
    match translatorToUse with
    | Translator.leanAuto => Smt.prepareAutoQuery mv (← Smt.parseAutoHints ⟨stx[1]⟩)
    | Translator.leanSmt => Smt.prepareLeanSmtQuery mv (← Smt.Tactic.parseHints ⟨stx[1]⟩)
  return cmdString

open Lean Elab Command Term Meta Tactic
/-- This performs the same simplifications as `fast_simplify_clause` on
the given expression and then passes it to the SMT translator.-/
def translateExprToSmt (expr: Expr) : TermElabM String := do
  let g ← mkFreshExprMVar expr
  let (cmdString, [l]) ← Tactic.run g.mvarId! (do
    tryGoal $ run `(tactic|(unhygienic intros); fast_simplify_clause)
    for mvarId in (← Tactic.getGoals) do
      liftM <| mvarId.refl <|> mvarId.inferInstance <|> pure ()
    Tactic.pruneSolvedGoals
    let cmdString ← getQueryForGoal
    return cmdString
   ) | throwError "[translateExprToSmt] expected exactly one goal after simplification"
  return cmdString

open Smt Smt.Tactic Translate Lean Lean.Meta Auto.Solver.SMT in
def querySolverWithIndicators (goalQuery : String) (withTimeout : Nat) (checks: Array (Array (Name × Expr))) (forceSolver : Option SolverName := none)
  : MetaM (List ((List Name) × SmtResult)) := do
  withTraceNode `sauto.perf.query (fun _ => return "querySolverWithIndicators") do
  let opts ← getOptions
    let solverName :=
      match forceSolver with
      | some s => s
      | none => sauto.smt.solver.get opts
    trace[sauto.debug] "solver: {solverName}"
  let solver ← createSolver solverName withTimeout
  if solverName == SolverName.cvc5 then
    emitCommand solver (.setLogic "ALL")
    emitCommand solver (.setOption (.produceProofs true))
  emitCommandStr solver s!"{goalQuery}\n"
  let mut ret := []
  let indicatorNames := (checks.map (fun arr => arr.map (fun (_, ind) => ind.constName!))).flatten
  for check in checks do
    trace[sauto.debug] "Now running solver"
    let variablesInCheck := (check.map (fun (act, _) => act)).toList
    let indicatorsInCheck := check.map (fun (_, ind) => ind.constName!)
    let checkName := indicatorsInCheck.foldl (fun acc new => s!"{mkPrintableName new}_{acc}") "_checkSatIndicator_"
    let expression ← indicatorNames.foldlM (fun acc new => do
      if indicatorsInCheck.contains new then
        return s!"{← indicatorVariableName new} {acc}"
      else return s!"(not {← indicatorVariableName new}) {acc}") ""
    try
      emitCommandStr solver s!"(define-fun {checkName} () Bool (and {expression}))\n"
      emitCommandStr solver s!"(check-sat-assuming ({checkName}))\n"
      let stdout ← Handle.readLineSkip solver.stdout
      let (checkSatResponse, _) ← getSexp stdout
      let checkSatResponse: SmtResult := match checkSatResponse with
        | .atom (.symb "sat") => SmtResult.Sat none
        | .atom (.symb "unsat") => SmtResult.Unsat
        | .atom (.symb "unknown") => SmtResult.Unknown ""
        | e => SmtResult.Failure s!"{e}"
      trace[sauto.debug] "Test result: {checkSatResponse}"
      ret := ret ++ [((variablesInCheck, checkSatResponse))]
    catch e =>
      let exMsg ← e.toMessageData.toString
      let stderr ← solver.stderr.readToEnd
      let stderr := if stderr.isEmpty then "" else s!"{stderr.trim}"
      trace[sauto.debug] "exception: {exMsg} | stderr: {stderr}"
      ret := ret ++ [((variablesInCheck, .Failure s!"{stderr}"))]

  trace[sauto.debug] "Results for all actions and invariants: {ret}"
  solver.kill
  return ret
