#lang ivy1.8

# Byzantine quorums (2f + 1 nodes) intersect in at least one honest member.
module byzantine_quorum(address, quorum) = {
    relation is_byz(A:address)
    relation member(A:address, Q:quorum)
    axiom [quorum_intersection]
        forall Q1:quorum, Q2:quorum. exists A:address. member(A, Q1) & member(A, Q2) & ~is_byz(A)
}

type quorum
type address
type round
type value

instance byzantine_quorum(address, quorum)

# Messages over the network
relation initial_msg(ORIGINATOR:address, DST:address, R:round, V:value)
relation echo_msg(SRC:address, DST:address, ORIGINATOR:address, R:round, V:value)
relation vote_msg(SRC:address, DST:address, ORIGINATOR:address, R:round, V:value)

# State of the nodes
# sent(address, round) := has the node initiated round `r`? 
relation sent(N:address, R:round)
relation echoed(N:address, ORIG:address, IN_ROUND:round, V:value)
relation voted(N:address, ORIG:address, IN_ROUND:round, V:value)
relation output(N:address, ORIG:address, IN_ROUND:round, V:value)

# Ghost relations
relation initial_value(N:address, R:round, V:value) = forall DST:address. initial_msg(N, DST, R, V)

after init {
    initial_msg(O, D, R, V) := false;
    echo_msg(S, D, O, R, V) := false;
    vote_msg(S, D, O, R, V) := false;

    sent(N, R) := false;
    echoed(N, O, R, V) := false;
    voted(N, O, R, V) := false;
    output(N, O, R, V) := false;
}

export action start_round(n:address, r:round, v:value) = {
    require ~sent(n, r);
    initial_msg(n, N, r, v) := true;
    sent(n, r) := true;
}

export action echo(n:address, orig:address, r:round, v:value) = {
    require initial_msg(orig, n, r, v);
    require ~echoed(n, orig, r, v);
    echoed(n, orig, r, v) := true;
    echo_msg(n, DST, orig, r, v) := true;
}

export action vote(n:address, orig:address, r:round, v:value) = {
    # received a quorum of echo messages OR a vote message from an honest node
    require (exists Q:quorum. forall SRC:address. member(SRC, Q) -> echo_msg(SRC, n, orig, r, v)) |
            (exists SRC:address. ~is_byz(SRC) & vote_msg(SRC, n, orig, r, v));
    require ~voted(n, orig, r, v);
    voted(n, orig, r, v) := true;
    vote_msg(n, DST, orig, r, v) := true;
}

export action deliver(n:address, orig:address, r:round, v:value) = {
    # received a quorum of votes
    require (exists Q:quorum. forall SRC:address. member(SRC, Q) -> vote_msg(SRC, n, orig, r, v));
    output(n, orig, r, v) := true;
}

# If a value is voted for, it is the value that was initially proposed by the originator.
invariant [vote_integrity]
    forall SRC:address, DST:address, R:round, V:value.
        ~is_byz(SRC) & ~is_byz(DST) & voted(DST, SRC, R, V) ->
        (sent(SRC, R) & initial_value(SRC, R, V))

# If a value is output, it is the value that was initially proposed by the originator.
invariant [output_integrity]
    forall SRC:address, DST:address, R:round, V:value.
        ~is_byz(SRC) & ~is_byz(DST) & output(DST, SRC, R, V) ->
        (sent(SRC, R) & initial_value(SRC, R, V))

# Also known as "output uniqueness".
invariant [agreement]
    forall SRC:address, DST1:address, DST2:address, R:round, V1:value, V2:value.
        ~is_byz(DST1) & ~is_byz(DST2) & output(DST1, SRC, R, V1) & output(DST2, SRC, R, V2) ->
        (V1 = V2)

# Looking at the actions

invariant [sent_iff_initial]
    forall SRC:address, R:round.
        ~is_byz(SRC) -> (sent(SRC, R) <-> exists V:value. initial_value(SRC, R, V))

invariant [echoed_iff_echo]
    forall N:address, DST:address, ORIG:address, R:round, V:value.
        echoed(N, ORIG, R, V) <-> echo_msg(N, DST, ORIG, R, V)

invariant [echoed_requires_initial]
    forall N:address, ORIG:address, R:round, V:value.
        echoed(N, ORIG, R, V) -> initial_msg(ORIG, N, R, V)

invariant [voted_iff_vote]
    forall N:address, DST:address, ORIG:address, R:round, V:value.
        voted(N, ORIG, R, V) <-> vote_msg(N, DST, ORIG, R, V)

# not in the decidable fragment due to edge from `address` to `quorum`
# invariant [voted_requires_echo_quorum]
#     forall N:address, ORIG:address, R:round, V:value.
#         voted(N, ORIG, R, V) -> exists Q:quorum. forall SRC:address. member(SRC, Q) -> echo_msg(SRC, N, ORIG, R, V)

# invariant [output_requires_vote]
#     forall N:address, ORIG:address, R:round, V:value.
#         output(N, ORIG, R, V) -> exists Q:quorum. forall SRC:address. member(SRC, Q) -> vote_msg(SRC, N, ORIG, R, V)

# Looking at CTIs

# vote -> vote_integrity

# this version is not in the decidable fragment:
# invariant [sent_iff_initial]
#    ∀ (src : address) (r : round),
#      sent src r ↔ ∃ (dst : address) (v : value), initial_msg src dst r v
# invariant [initial_value_iff_initial_msg]
#   ∀ (src dst : address) (r : round) (v : value),
#     initial_value src r v ↔ initial_msg src dst r v

invariant [initial_value_iff_initial_msg]
    forall SRC:address, DST:address, R:round, V:value.
        initial_value(SRC, R, V) <-> initial_msg(SRC, DST, R, V)

# deliver -> agreement
